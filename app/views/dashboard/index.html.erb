<div class="flex h-screen relative" style="background-color: #F5F5F7;"
     data-default-habits-grouping="<%= current_user.default_habits_grouping %>"
     data-default-tasks-grouping="<%= current_user.default_tasks_grouping %>">
  <%= render 'shared/sidebar' %>

  <!-- Mobile overlay -->
  <div id="sidebar-overlay" class="fixed inset-0 bg-black/50 z-30 md:hidden hidden"></div>

  <!-- Menu flag button -->
  <button id="menu-button" class="fixed left-0 z-20 md:hidden rounded-r-lg shadow-lg flex items-center justify-center py-1.5 px-3 cursor-move"
    style="top: 200px; background: linear-gradient(135deg, #424245, #2C2C2E); writing-mode: vertical-rl;">
    <span class="text-white font-bold text-sm tracking-wider">MENU</span>
  </button>

  <script>
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('sidebar-overlay');
    const menuButton = document.getElementById('menu-button');
    const closeButton = document.getElementById('sidebar-close');

    function openSidebar() {
      sidebar.classList.remove('-translate-x-full');
      sidebar.classList.add('translate-x-0');
      overlay.classList.remove('hidden');
      menuButton.classList.add('hidden');
    }

    function closeSidebar() {
      sidebar.classList.add('-translate-x-full');
      sidebar.classList.remove('translate-x-0');
      overlay.classList.add('hidden');
      menuButton.classList.remove('hidden');
    }

    // Draggable menu button
    let isDragging = false;
    let startY = 0;
    let startTop = 200;
    let dragStartTime = 0;

    menuButton.addEventListener('mousedown', (e) => {
      isDragging = true;
      dragStartTime = Date.now();
      startY = e.clientY;
      startTop = parseInt(menuButton.style.top) || 200;
      e.preventDefault();
    });

    menuButton.addEventListener('touchstart', (e) => {
      isDragging = true;
      dragStartTime = Date.now();
      startY = e.touches[0].clientY;
      startTop = parseInt(menuButton.style.top) || 200;
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaY = e.clientY - startY;
        const newTop = Math.max(0, Math.min(window.innerHeight - menuButton.offsetHeight, startTop + deltaY));
        menuButton.style.top = newTop + 'px';
        localStorage.setItem('menuButtonTop', newTop);
      }
    });

    document.addEventListener('touchmove', (e) => {
      if (isDragging) {
        const deltaY = e.touches[0].clientY - startY;
        const newTop = Math.max(0, Math.min(window.innerHeight - menuButton.offsetHeight, startTop + deltaY));
        menuButton.style.top = newTop + 'px';
        localStorage.setItem('menuButtonTop', newTop);
      }
    });

    document.addEventListener('mouseup', (e) => {
      if (isDragging) {
        const dragDuration = Date.now() - dragStartTime;
        const dragDistance = Math.abs(e.clientY - startY);

        if (dragDuration < 200 && dragDistance < 5) {
          openSidebar();
        }
        isDragging = false;
      }
    });

    document.addEventListener('touchend', (e) => {
      if (isDragging) {
        const dragDuration = Date.now() - dragStartTime;
        if (dragDuration < 200) {
          openSidebar();
        }
        isDragging = false;
      }
    });

    closeButton.addEventListener('click', closeSidebar);
    overlay.addEventListener('click', closeSidebar);

    const savedTop = localStorage.getItem('menuButtonTop');
    if (savedTop) {
      menuButton.style.top = savedTop + 'px';
    }
  </script>

  <!-- Main Content Area -->
  <main class="flex-1 overflow-y-auto" style="background-color: #F5F5F7;">
    <!-- White Header Section with Shadow -->
    <div class="sticky top-0 z-10" style="background: #FFFFFF; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);">
      <div class="p-8">
        <div class="flex items-start justify-between mb-6">
          <div class="flex-1">
            <h1 class="text-5xl font-display" style="color: #1D1D1F;">
              Daily Briefing
            </h1>
            <p class="text-sm mt-1" style="color: #8E8E93; font-weight: 400; font-family: 'Inter', sans-serif;"><%= @today.strftime('%A, %B %d, %Y') %></p>
          </div>

          <!-- Date Navigation -->
          <div class="flex flex-col items-center gap-1">
            <div class="flex items-center gap-2">
              <%= link_to dashboard_path(date: (@today - 1.day).strftime('%Y-%m-%d')),
                  class: "w-10 h-10 rounded-lg flex items-center justify-center transition",
                  style: "background: linear-gradient(135deg, rgba(229, 229, 231, 0.3) 0%, rgba(199, 199, 204, 0.4) 50%, rgba(142, 142, 147, 0.3) 100%); border: 0.5px solid rgba(199, 199, 204, 0.3); box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.2);" do %>
                <i class="fa-solid fa-chevron-left text-sm" style="color: #2C2C2E;"></i>
              <% end %>

              <div class="px-2 text-sm min-w-[60px] text-center" style="color: #1D1D1F; font-weight: 600; font-family: 'Inter', sans-serif;">
                <%= @today == Time.zone.today ? 'Today' : @today.strftime('%m/%d') %>
              </div>

              <% if @today < Time.zone.today %>
                <%= link_to dashboard_path(date: (@today + 1.day).strftime('%Y-%m-%d')),
                    class: "w-10 h-10 rounded-lg flex items-center justify-center transition",
                    style: "background: linear-gradient(135deg, rgba(229, 229, 231, 0.3) 0%, rgba(199, 199, 204, 0.4) 50%, rgba(142, 142, 147, 0.3) 100%); border: 0.5px solid rgba(199, 199, 204, 0.3); box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.2);" do %>
                  <i class="fa-solid fa-chevron-right text-sm" style="color: #2C2C2E;"></i>
                <% end %>
              <% else %>
                <div class="w-10 h-10 rounded-lg flex items-center justify-center opacity-30 pointer-events-none" style="background: linear-gradient(135deg, rgba(229, 229, 231, 0.3) 0%, rgba(199, 199, 204, 0.4) 50%, rgba(142, 142, 147, 0.3) 100%); border: 0.5px solid rgba(199, 199, 204, 0.3);">
                  <i class="fa-solid fa-chevron-right text-sm" style="color: #2C2C2E;"></i>
                </div>
              <% end %>
            </div>

            <% if @today != Time.zone.today %>
              <%= link_to "BACK TO TODAY", dashboard_path,
                  class: "text-xs mt-1 hover:opacity-70 transition uppercase tracking-wide",
                  style: "color: #8E8E93; font-family: 'Inter', sans-serif; font-weight: 300;" %>
            <% end %>
          </div>
        </div>
      </div>
    </div>

    <!-- Grey Background Content -->
    <div class="p-8 pt-6 space-y-6">
      <%
        # Get layout and sort by position
        layout = current_user.dashboard_layout.presence || User::DEFAULT_DASHBOARD_LAYOUT
        visible_blocks = layout.select { |b| b['visible'] != false }.sort_by { |b| b['position'] || 0 }

        # Group blocks into rows: full-width blocks get their own row, left/right blocks are paired
        rows = []
        current_row = { left: nil, right: nil }

        visible_blocks.each do |block|
          if block['column'] == 'full'
            # Flush any pending left/right row first
            if current_row[:left] || current_row[:right]
              rows << current_row
              current_row = { left: nil, right: nil }
            end
            rows << { full: block }
          elsif block['column'] == 'left'
            if current_row[:left]
              # Already have a left block, flush and start new row
              rows << current_row
              current_row = { left: block, right: nil }
            else
              current_row[:left] = block
            end
          else # right
            if current_row[:right]
              # Already have a right block, flush and start new row
              rows << current_row
              current_row = { left: nil, right: block }
            else
              current_row[:right] = block
            end
          end
        end
        # Don't forget the last row
        rows << current_row if current_row[:left] || current_row[:right]
      %>

      <% rows.each do |row| %>
        <% if row[:full] %>
          <!-- Full Width Block -->
          <% case row[:full]['block'] %>
          <% when 'calendar' %>
            <%= render 'dashboard/calendar_block' %>
          <% when 'quick_links' %>
            <%= render 'dashboard/quick_links_block' %>
          <% when 'habits' %>
            <%= render 'dashboard/habits_block' %>
          <% when 'tasks' %>
            <%= render 'dashboard/tasks_block' %>
          <% when 'daily_prep' %>
            <%= render 'dashboard/daily_prep_block' %>
          <% end %>
        <% else %>
          <!-- Two Column Row -->
          <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
              <% if row[:left] %>
                <% case row[:left]['block'] %>
                <% when 'calendar' %>
                  <%= render 'dashboard/calendar_block' %>
                <% when 'quick_links' %>
                  <%= render 'dashboard/quick_links_block' %>
                <% when 'habits' %>
                  <%= render 'dashboard/habits_block' %>
                <% when 'tasks' %>
                  <%= render 'dashboard/tasks_block' %>
                <% when 'daily_prep' %>
                  <%= render 'dashboard/daily_prep_block' %>
                <% end %>
              <% end %>
            </div>
            <div>
              <% if row[:right] %>
                <% case row[:right]['block'] %>
                <% when 'calendar' %>
                  <%= render 'dashboard/calendar_block' %>
                <% when 'quick_links' %>
                  <%= render 'dashboard/quick_links_block' %>
                <% when 'habits' %>
                  <%= render 'dashboard/habits_block' %>
                <% when 'tasks' %>
                  <%= render 'dashboard/tasks_block' %>
                <% when 'daily_prep' %>
                  <%= render 'dashboard/daily_prep_block' %>
                <% end %>
              <% end %>
            </div>
          </div>
        <% end %>
      <% end %>
    </div>
  </main>
</div>

<!-- React Modal Root for Dashboard -->
<div id="dashboard-modals-root"></div>

<script>
// Today's Focus view toggle
function switchFocusView(view) {
  const container = document.getElementById('focus-habits-container');
  const timeBtn = document.getElementById('focus-time-btn');
  const categoryBtn = document.getElementById('focus-category-btn');
  const priorityBtn = document.getElementById('focus-priority-btn');

  // Update button styles
  timeBtn.style.background = '';
  timeBtn.style.boxShadow = '';
  timeBtn.style.color = '#8E8E93';
  categoryBtn.style.background = '';
  categoryBtn.style.boxShadow = '';
  categoryBtn.style.color = '#8E8E93';
  priorityBtn.style.background = '';
  priorityBtn.style.boxShadow = '';
  priorityBtn.style.color = '#8E8E93';

  if (view === 'time') {
    timeBtn.style.background = 'linear-gradient(135deg, #2C2C2E, #1D1D1F)';
    timeBtn.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.2)';
    timeBtn.style.color = 'white';
  } else if (view === 'category') {
    categoryBtn.style.background = 'linear-gradient(135deg, #2C2C2E, #1D1D1F)';
    categoryBtn.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.2)';
    categoryBtn.style.color = 'white';
  } else {
    priorityBtn.style.background = 'linear-gradient(135deg, #2C2C2E, #1D1D1F)';
    priorityBtn.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.2)';
    priorityBtn.style.color = 'white';
  }

  // Get all habit items
  const habitItems = Array.from(container.querySelectorAll('.habit-item'));

  // Group and sort based on view
  let groups = {};
  let groupOrder = [];
  let groupIcons = {};

  if (view === 'time') {
    // Group by user-defined time blocks
    const timeGroups = {};

    habitItems.forEach(item => {
      const group = item.dataset.timeGroup;
      const name = item.dataset.timeBlockName;
      const rank = parseInt(item.dataset.timeBlockRank);
      const color = item.dataset.timeBlockColor;
      const icon = item.dataset.timeBlockIcon;

      if (!timeGroups[group]) {
        timeGroups[group] = {
          name: name,
          rank: rank,
          color: color,
          icon: icon,
          items: []
        };
      }
      timeGroups[group].items.push(item);
    });

    // Sort groups by rank (anytime will have rank 999)
    groupOrder = Object.keys(timeGroups).sort((a, b) => {
      return timeGroups[a].rank - timeGroups[b].rank;
    });

    // Build groups object and icons
    groupOrder.forEach(key => {
      groups[key] = timeGroups[key].items;
      groupIcons[key] = timeGroups[key].icon;
    });
  } else if (view === 'category') {
    // Group by category
    const categoryGroups = {};

    habitItems.forEach(item => {
      const group = item.dataset.categoryGroup;
      const name = item.dataset.categoryName;
      const color = item.dataset.categoryColor;
      const icon = item.dataset.categoryIcon;

      if (!categoryGroups[group]) {
        categoryGroups[group] = {
          name: name,
          color: color,
          icon: icon,
          items: []
        };
      }
      categoryGroups[group].items.push(item);
    });

    // Sort groups alphabetically by name
    groupOrder = Object.keys(categoryGroups).sort((a, b) => {
      return categoryGroups[a].name.localeCompare(categoryGroups[b].name);
    });

    // Build groups object and icons
    groupOrder.forEach(key => {
      groups[key] = categoryGroups[key].items;
      groupIcons[key] = categoryGroups[key].icon;
    });
  } else {
    // Group by user-defined importance levels
    const priorityGroups = {};

    habitItems.forEach(item => {
      const group = item.dataset.priorityGroup;
      const name = item.dataset.priorityName;
      const rank = parseInt(item.dataset.priorityRank);
      const color = item.dataset.priorityColor;
      const icon = item.dataset.priorityIcon;

      if (!priorityGroups[group]) {
        priorityGroups[group] = {
          name: name,
          rank: rank,
          color: color,
          icon: icon,
          items: []
        };
      }
      priorityGroups[group].items.push(item);
    });

    // Sort groups by rank
    groupOrder = Object.keys(priorityGroups).sort((a, b) => {
      return priorityGroups[a].rank - priorityGroups[b].rank;
    });

    // Build groups object and icons
    groupOrder.forEach(key => {
      groups[key] = priorityGroups[key].items;
      groupIcons[key] = priorityGroups[key].icon;
    });
  }

  // Clear container
  container.innerHTML = '';

  // Rebuild with headers
  let isFirst = true;
  groupOrder.forEach(groupName => {
    if (!groups[groupName] || groups[groupName].length === 0) return;

    // Get color based on view
    let groupColor = '#8E8E93'; // Default metallic grey for time
    let groupIconClass = groupIcons[groupName] || 'fa-clock';
    let groupTitle = groupName.charAt(0).toUpperCase() + groupName.slice(1);

    if (view === 'category' && groups[groupName].length > 0) {
      groupColor = groups[groupName][0].dataset.categoryColor;
      groupTitle = groups[groupName][0].dataset.categoryName;
    } else if (view === 'priority' && groups[groupName].length > 0) {
      groupColor = groups[groupName][0].dataset.priorityColor;
      groupTitle = groups[groupName][0].dataset.priorityName;
    } else if (view === 'time' && groups[groupName].length > 0) {
      groupColor = '#8E8E93'; // Metallic grey for time blocks
      groupTitle = groups[groupName][0].dataset.timeBlockName;
    }

    // Create group container
    const groupDiv = document.createElement('div');
    groupDiv.className = isFirst ? 'mb-4' : 'mb-4 mt-4';

    // Create full-width stripe header
    const headerDiv = document.createElement('div');
    headerDiv.className = '-mx-6 px-6 py-2 mb-3 flex items-center gap-2';
    headerDiv.style.background = `linear-gradient(to bottom, color-mix(in srgb, ${groupColor} 85%, white) 0%, ${groupColor} 100%)`;
    headerDiv.style.boxShadow = '0 2px 6px rgba(0, 0, 0, 0.1)';

    // Add icon
    const icon = document.createElement('i');
    icon.className = `fa-solid ${groupIconClass} text-white text-sm`;
    headerDiv.appendChild(icon);

    // Add title
    const title = document.createElement('span');
    title.className = 'text-lg text-white font-display';
    title.style.fontWeight = '500';
    title.textContent = groupTitle;
    headerDiv.appendChild(title);

    // Create habits container
    const habitsDiv = document.createElement('div');
    habitsDiv.className = 'space-y-2';

    // Sort items: Daily → Scheduled → Optional
    const sortedItems = groups[groupName].sort((a, b) => {
      const aOptional = a.dataset.priorityName === 'Optional';
      const bOptional = b.dataset.priorityName === 'Optional';
      const aScheduled = a.dataset.isScheduled === 'true';
      const bScheduled = b.dataset.isScheduled === 'true';

      // Optional items go last
      if (aOptional && !bOptional) return 1;
      if (!aOptional && bOptional) return -1;

      // Among non-optional: Daily (not scheduled) first, then Scheduled
      if (!aOptional && !bOptional) {
        if (!aScheduled && bScheduled) return -1;
        if (aScheduled && !bScheduled) return 1;
      }

      return 0;
    });

    sortedItems.forEach(habitItem => {
      const isOptional = habitItem.dataset.priorityName === 'Optional';
      const isScheduled = habitItem.dataset.isScheduled === 'true';

      // Apply background styling based on type
      if (isOptional) {
        // Optional: grey background
        habitItem.style.backgroundColor = 'rgba(142, 142, 147, 0.08)';
        habitItem.style.borderRadius = '6px';
        habitItem.style.padding = '4px 8px';
        habitItem.style.margin = '0 -8px';
      } else if (isScheduled) {
        // Scheduled (non-daily): very subtle indigo tint (lighter than optional)
        habitItem.style.backgroundColor = 'rgba(99, 102, 241, 0.03)';
        habitItem.style.borderRadius = '6px';
        habitItem.style.padding = '4px 8px';
        habitItem.style.margin = '0 -8px';
      } else {
        // Daily: no background
        habitItem.style.backgroundColor = '';
        habitItem.style.borderRadius = '';
        habitItem.style.padding = '';
        habitItem.style.margin = '';
      }
      habitsDiv.appendChild(habitItem);
    });

    groupDiv.appendChild(headerDiv);
    groupDiv.appendChild(habitsDiv);
    container.appendChild(groupDiv);
    isFirst = false;
  });
}

// Track all habits and their completion states
const habitStates = new Map();
let totalHabitsCount = 0;

// Initialize habit states on page load
document.addEventListener('DOMContentLoaded', () => {
  // Initialize habit states BEFORE reorganizing view
  document.querySelectorAll('.habit-item[data-habit-id]').forEach(row => {
    const habitId = parseInt(row.dataset.habitId);
    const targetCount = parseInt(row.dataset.target);
    const countText = row.querySelector('.text-xs').textContent.trim();
    const currentCount = parseInt(countText.split('/')[0]);

    habitStates.set(habitId, {
      currentCount,
      targetCount,
      isComplete: currentCount >= targetCount
    });
  });
  totalHabitsCount = habitStates.size;

  // Get user's default habits grouping preference
  const container = document.querySelector('[data-default-habits-grouping]');
  const userHabitsGrouping = container?.dataset?.defaultHabitsGrouping || 'time';

  // Map user preference to dashboard view options
  // Dashboard supports: 'time', 'category', 'priority'
  // User settings: 'none', 'category', 'time', 'priority'
  const habitsViewMap = {
    'none': 'time',      // Fallback - dashboard doesn't have 'none'
    'category': 'category',
    'time': 'time',
    'priority': 'priority'
  };
  const initialHabitsView = habitsViewMap[userHabitsGrouping] || 'time';

  switchFocusView(initialHabitsView);
});

async function toggleDashboardHabit(habitId, wasComplete) {
  const action = wasComplete ? 'decrement' : 'increment';

  // Find the habit row - use more specific selector
  const habitRow = document.querySelector(`.habit-item[data-habit-id="${habitId}"]`);
  if (!habitRow) {
    console.error('Could not find habit row for ID:', habitId);
    return;
  }

  const button = habitRow.querySelector('button');
  const icon = button.querySelector('i');

  // Save original state and show spinner
  const originalIconClass = icon.className;
  const originalIconColor = icon.style.color;
  icon.className = 'fa-solid fa-spinner fa-spin text-sm';
  button.disabled = true;

  try {
    const response = await fetch(`/habits/${habitId}/completions/${action}`, {
      method: 'POST',
      headers: {
        'X-CSRF-Token': document.querySelector('[name=csrf-token]').content,
        'Content-Type': 'application/json'
      }
    });

    const data = await response.json();

    const nameDiv = habitRow.querySelector('.flex-1');
    const countDiv = habitRow.querySelector('.text-xs');
    const targetCount = parseInt(habitRow.dataset.target);

    // Get category colors from data attributes
    const categoryColor = habitRow.dataset.categoryColor;
    const lightColor = habitRow.dataset.lightColor;

    // Store habit's health data for later updates
    habitRow.dataset.health = data.health;

    // Update state
    const oldState = habitStates.get(habitId);
    const newIsComplete = data.count >= targetCount;
    const statusChanged = oldState && oldState.isComplete !== newIsComplete;

    habitStates.set(habitId, {
      currentCount: data.count,
      targetCount,
      isComplete: newIsComplete
    });

    // Update UI
    if (newIsComplete) {
      icon.className = 'fa-solid fa-circle-check text-sm';
      icon.style.color = categoryColor;
      nameDiv.classList.add('line-through', 'opacity-60');
      nameDiv.style.color = lightColor;
    } else {
      icon.className = 'fa-regular fa-circle text-sm';
      icon.style.color = lightColor;
      nameDiv.classList.remove('line-through', 'opacity-60');
      nameDiv.style.color = categoryColor;
    }

    countDiv.textContent = `${data.count} / ${targetCount}`;
    button.setAttribute('onclick', `toggleDashboardHabit(${habitId}, ${newIsComplete})`);

    // Recalculate totals
    let totalComplete = 0;
    habitStates.forEach(state => {
      if (state.isComplete) totalComplete++;
    });

    const percentage = totalHabitsCount > 0 ? Math.round((totalComplete * 100) / totalHabitsCount) : 0;

    // Update header
    const completionHeader = document.getElementById('today-completion-count');
    if (completionHeader) {
      completionHeader.textContent = `${totalComplete} / ${totalHabitsCount} completed (${percentage}%)`;
    }

  } catch (error) {
    console.error('Error toggling habit:', error);
    // Restore original icon on error
    icon.className = originalIconClass;
    icon.style.color = originalIconColor;
  } finally {
    button.disabled = false;
  }
}

// Tasks view toggle
function switchTasksView(view) {
  const container = document.getElementById('tasks-container');
  const dateBtn = document.getElementById('tasks-date-btn');
  const categoryBtn = document.getElementById('tasks-category-btn');
  const priorityBtn = document.getElementById('tasks-priority-btn');

  // Update button styles
  dateBtn.style.background = '';
  dateBtn.style.boxShadow = '';
  dateBtn.style.color = '#8E8E93';
  categoryBtn.style.background = '';
  categoryBtn.style.boxShadow = '';
  categoryBtn.style.color = '#8E8E93';
  priorityBtn.style.background = '';
  priorityBtn.style.boxShadow = '';
  priorityBtn.style.color = '#8E8E93';

  if (view === 'date') {
    dateBtn.style.background = 'linear-gradient(135deg, #2C2C2E, #1D1D1F)';
    dateBtn.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.2)';
    dateBtn.style.color = 'white';
  } else if (view === 'category') {
    categoryBtn.style.background = 'linear-gradient(135deg, #2C2C2E, #1D1D1F)';
    categoryBtn.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.2)';
    categoryBtn.style.color = 'white';
  } else {
    priorityBtn.style.background = 'linear-gradient(135deg, #2C2C2E, #1D1D1F)';
    priorityBtn.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.2)';
    priorityBtn.style.color = 'white';
  }

  // Get all task items
  const taskItems = Array.from(container.querySelectorAll('.task-item'));

  if (taskItems.length === 0) return;

  // Group and sort based on view
  let groups = {};
  let groupOrder = [];
  let groupLabels = {};
  let groupColors = {};

  if (view === 'date') {
    groupOrder = ['overdue', 'today', 'no_date', 'future'];
    groupLabels = {
      'overdue': 'Overdue',
      'today': 'Due Today',
      'no_date': 'No Due Date',
      'future': 'Upcoming'
    };
    groupColors = {
      'overdue': '#F8796D',
      'today': '#1d3e4c',
      'no_date': '#657b84',
      'future': '#657b84'
    };

    taskItems.forEach(item => {
      const group = item.dataset.dateGroup;
      if (!groups[group]) groups[group] = [];
      groups[group].push(item);
    });
  } else if (view === 'category') {
    // Group by category
    const categoryGroups = {};

    taskItems.forEach(item => {
      const group = item.dataset.categoryGroup;
      const name = item.dataset.categoryName;
      const color = item.dataset.categoryColor;

      if (!categoryGroups[group]) {
        categoryGroups[group] = {
          name: name,
          color: color,
          items: []
        };
      }
      categoryGroups[group].items.push(item);
    });

    // Sort groups alphabetically by name
    groupOrder = Object.keys(categoryGroups).sort((a, b) => {
      return categoryGroups[a].name.localeCompare(categoryGroups[b].name);
    });

    // Build groups object and labels
    groupOrder.forEach(key => {
      groups[key] = categoryGroups[key].items;
      groupLabels[key] = categoryGroups[key].name;
      groupColors[key] = categoryGroups[key].color;
    });
  } else {
    // Group by priority
    const priorityGroups = {};

    taskItems.forEach(item => {
      const group = item.dataset.priorityGroup;
      const name = item.dataset.priorityName;
      const rank = parseInt(item.dataset.priorityRank);
      const color = item.dataset.priorityColor;
      const icon = item.dataset.priorityIcon;

      if (!priorityGroups[group]) {
        priorityGroups[group] = {
          name: name,
          rank: rank,
          color: color,
          icon: icon,
          items: []
        };
      }
      priorityGroups[group].items.push(item);
    });

    // Sort groups by rank
    groupOrder = Object.keys(priorityGroups).sort((a, b) => {
      return priorityGroups[a].rank - priorityGroups[b].rank;
    });

    // Build groups object, labels, and colors
    groupOrder.forEach(key => {
      groups[key] = priorityGroups[key].items;
      groupLabels[key] = priorityGroups[key].name;
      groupColors[key] = priorityGroups[key].color;
    });
  }

  // Clear container
  container.innerHTML = '';

  // Define icons for date groups
  const dateIcons = {
    'overdue': 'fa-exclamation-triangle',
    'today': 'fa-calendar-day',
    'no_date': 'fa-infinity',
    'future': 'fa-calendar-alt'
  };

  // Rebuild with headers
  let isFirst = true;
  groupOrder.forEach(groupName => {
    if (!groups[groupName] || groups[groupName].length === 0) return;

    // Get color and icon based on view
    let groupColor = '#8E8E93'; // Default metallic grey
    let groupIconClass = 'fa-list';
    let groupTitle = groupLabels[groupName] || groupName;

    if (view === 'date') {
      groupColor = '#8E8E93'; // Metallic grey for date groups
      groupIconClass = dateIcons[groupName] || 'fa-calendar';
    } else if (view === 'category' && groups[groupName].length > 0) {
      groupColor = groupColors[groupName] || '#8E8E93';
      groupIconClass = groups[groupName][0].dataset.categoryIcon || 'fa-folder';
    } else if (view === 'priority' && groups[groupName].length > 0) {
      groupColor = groupColors[groupName] || '#8E8E93';
      groupIconClass = groups[groupName][0].dataset.priorityIcon || 'fa-star';
    }

    // Create group container
    const groupDiv = document.createElement('div');
    groupDiv.className = isFirst ? 'mb-4' : 'mb-4 mt-4';

    // Create full-width stripe header
    const headerDiv = document.createElement('div');
    headerDiv.className = '-mx-6 px-6 py-2 mb-3 flex items-center gap-2';
    headerDiv.style.background = `linear-gradient(to bottom, color-mix(in srgb, ${groupColor} 85%, white) 0%, ${groupColor} 100%)`;
    headerDiv.style.boxShadow = '0 2px 6px rgba(0, 0, 0, 0.1)';

    // Add icon
    const icon = document.createElement('i');
    icon.className = `fa-solid ${groupIconClass} text-white text-sm`;
    headerDiv.appendChild(icon);

    // Add title
    const title = document.createElement('span');
    title.className = 'text-lg text-white font-display';
    title.style.fontWeight = '500';
    title.textContent = groupTitle;
    headerDiv.appendChild(title);

    // Create tasks container
    const tasksDiv = document.createElement('div');
    tasksDiv.className = 'space-y-2';

    // Sort items: non-optional first, optional last
    const sortedItems = groups[groupName].sort((a, b) => {
      const aOptional = a.dataset.priorityName === 'Optional';
      const bOptional = b.dataset.priorityName === 'Optional';
      if (aOptional && !bOptional) return 1;
      if (!aOptional && bOptional) return -1;
      return 0;
    });

    sortedItems.forEach(taskItem => {
      // Add subtle grey background for optional items
      if (taskItem.dataset.priorityName === 'Optional') {
        taskItem.style.backgroundColor = 'rgba(142, 142, 147, 0.08)';
        taskItem.style.borderRadius = '6px';
        taskItem.style.padding = '4px 8px';
        taskItem.style.margin = '0 -8px';
      } else {
        taskItem.style.backgroundColor = '';
        taskItem.style.borderRadius = '';
        taskItem.style.padding = '';
        taskItem.style.margin = '';
      }
      tasksDiv.appendChild(taskItem);
    });

    groupDiv.appendChild(headerDiv);
    groupDiv.appendChild(tasksDiv);
    container.appendChild(groupDiv);
    isFirst = false;
  });
}

// Initialize tasks view on page load
document.addEventListener('DOMContentLoaded', () => {
  const tasksContainer = document.getElementById('tasks-container');
  if (tasksContainer && tasksContainer.querySelectorAll('.task-item').length > 0) {
    // Get user's default tasks grouping preference
    const container = document.querySelector('[data-default-tasks-grouping]');
    const userTasksGrouping = container?.dataset?.defaultTasksGrouping || 'due_date';

    // Map user preference to dashboard view options
    // Dashboard supports: 'date', 'category', 'priority'
    // User settings: 'none', 'status', 'category', 'due_date', 'importance'
    const tasksViewMap = {
      'none': 'date',        // Fallback - dashboard doesn't have 'none'
      'status': 'date',      // Fallback - Date Added doesn't exist on dashboard
      'category': 'category',
      'due_date': 'date',
      'importance': 'priority'
    };
    const initialTasksView = tasksViewMap[userTasksGrouping] || 'date';

    switchTasksView(initialTasksView);
  }
});

// Toggle task completion
async function toggleTask(taskId, wasCompleted) {
  const newCompleted = !wasCompleted;

  // Find the task item and show spinner
  const taskItem = document.querySelector(`.task-item[data-task-id="${taskId}"]`);
  if (!taskItem) {
    console.error('Could not find task item for ID:', taskId);
    return;
  }

  const button = taskItem.querySelector('button');
  const icon = button.querySelector('i');
  const dateGroup = taskItem.dataset.dateGroup;
  const color = dateGroup === 'overdue' ? '#F8796D' : (dateGroup === 'today' ? '#1d3e4c' : '#657b84');

  // Save original icon state and show spinner
  const originalIconClass = icon.className;
  icon.className = 'fa-solid fa-spinner fa-spin text-xs';
  button.disabled = true;

  try {
    const response = await fetch(`/tasks/${taskId}`, {
      method: 'PATCH',
      headers: {
        'X-CSRF-Token': document.querySelector('[name=csrf-token]').content,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        task: {
          completed: newCompleted,
          completed_at: newCompleted ? new Date().toISOString() : null
        }
      })
    });

    const data = await response.json();

    if (data.success) {
      // Update data attribute
      taskItem.dataset.completed = newCompleted;

      // Find name span
      const nameSpan = taskItem.querySelector('.flex-1');

      // Update UI
      if (newCompleted) {
        icon.className = 'fa-solid fa-circle-check text-xs';
        icon.style.color = color;
        nameSpan.classList.add('line-through', 'opacity-60');
      } else {
        icon.className = 'fa-regular fa-circle text-xs';
        icon.style.color = color;
        nameSpan.classList.remove('line-through', 'opacity-60');
      }

      button.setAttribute('onclick', `toggleTask(${taskId}, ${newCompleted})`);
    } else {
      console.error('Error toggling task:', data.errors);
      // Restore original icon on error
      icon.className = originalIconClass;
    }
  } catch (error) {
    console.error('Error toggling task:', error);
    // Restore original icon on error
    icon.className = originalIconClass;
  } finally {
    button.disabled = false;
  }
}
</script>
